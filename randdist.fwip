#    Copyright (C) 2015-2020 by Kevin D. Woerner
# 2020-07-27 kdw  block syntax
# 2020-07-24 kdw  s/LO[C]AL_/BL[O]CK_/
# 2020-07-14 kdw  s/px/pbrx/g
# 2020-07-12 kdw  sqrttwo const
# 2020-07-10 kdw  normal cdf approx func
# 2020-07-01 kdw  tests modified
# 2020-06-30 kdw  tests changed
# 2020-06-22 kdw  local-use mved before var decls
# 2020-06-08 kdw  integral function stuff
# 2020-06-06 kdw  Gompertz distribution
# 2020-05-14 kdw  local funcs only in blocks
# 2020-05-11 kdw  BL[O]CK work
# 2020-05-06 kdw  rmed boolean vars
# 2020-05-05 kdw  magic check func changed
# 2020-04-30 kdw  trap[_]rand rework
# 2020-04-24 kdw  comments; const renam
# 2020-04-14 kdw  tests added
# 2020-04-12 kdw  comment change
# 2020-04-10 kdw  comment change
# 2020-04-08 kdw  preprocess sigil change
# 2020-04-07 kdw  comment; dup func rmed
# 2020-04-02 kdw  tweak here and there
# 2020-04-01 kdw  t quantile work
# 2020-03-30 kdw  s/_cdfinv/_quantile/g
# 2020-03-30 kdw  comment change
# 2020-03-29 kdw  func renam
# 2020-03-27 kdw  nbd and polya work
# 2020-03-26 kdw  _cdf trap inv func
# 2020-03-25 kdw  tri and trap simplified
# 2020-03-20 kdw  tri and trap work
# 2020-03-10 kdw  fixed pd[f]bb
# 2020-03-09 kdw  LO[C]AL_.* keywords
# 2020-03-05 kdw  s/TRU[E]VAL/TR[U]E/;s/FALS[E]VAL/FA[L]SE/
# 2020-03-03 kdw  comment change
# 2020-03-02 kdw  s/_NE[X]T/_E[N]D/g;
# 2020-02-28 kdw  poly eval work
# 2020-02-27 kdw  comment change
# 2020-02-26 kdw  arr[a]y and hor[n]er work
# 2020-02-16 kdw  array comments change
# 2020-02-14 kdw  incomplete beta work
# 2020-02-06 kdw  ks debugging II
# 2020-02-04 kdw  ks debugging
# 2020-02-03 kdw  more funcs have single return
# 2020-01-15 kdw  more arg checks in [cp]dfgeo()
# 2020-01-08 kdw  added several rand.* funcs
# 2019-12-31 kdw  maxwell-juttner distribution
# 2019-12-27 kdw  comments changed
# 2019-12-26 kdw  module name addded to funcs
# 2019-12-20 kdw  _pdf[mb]b long names
# 2019-11-20 kdw  black-body work II
# 2019-11-18 kdw  black-body work
# 2019-11-17 kdw  include Macros file
# 2019-10-23 kdw  lntwo const
# 2019-10-14 kdw  comment change
# 2019-10-04 kdw  comment change
# 2019-08-24 kdw  for and count loops have from clause
# 2019-08-22 kdw  comment changed
# 2019-08-18 kdw  B[O]OL to B[O]L
# 2019-08-17 kdw  L[O]G to LN
# 2019-08-11 kdw  comment cleanup
# 2019-08-06 kdw  rmed backslashes;macro arg renam
# 2019-07-22 kdw  func comments
# 2019-05-31 kdw  NR_DO to RAPHSON_LOOP; et al
# 2019-05-29 kdw  comment changed
# 2019-05-24 kdw  local replaced private
# 2019-05-20 kdw  rm unneeded comments; s/function/func/
# 2019-05-01 kdw  consts explicit module name
# 2019-03-19 kdw  re[t]_val to re[t]valu
# 2019-03-18 kdw  macro syntax changed
# 2019-03-16 kdw  tweak
# 2019-03-11 kdw  comments to array dcls
# 2019-03-08 kdw  is[e]qual to is[e]q, et al.
# 2019-03-06 kdw  is.* funcs changed
# 2019-01-03 kdw  Await counter changed
# 2018-11-29 kdw  upper cased fwip defined funcs
# 2018-10-05 kdw  l[o]g to L[O]G
# 2018-09-17 kdw  zipf and zeta dists
# 2018-09-13 kdw  cdf[t]inv2 fix
# 2018-07-25 kdw  cdf[k]s_a
# 2018-07-22 kdw  lf_cdftinv_gt_half
# 2018-07-19 kdw  comments; array reformat
# 2018-07-17 kdw  private lf_.* funcs
# 2018-07-14 kdw  float num format
# 2018-07-11 kdw  var nam change
# 2018-06-09 kdw  mved tests
# 2018-06-08 kdw  tests
# 2018-05-17 kdw  ARR?AY.* and HOR[N]ER syntax
# 2018-05-16 kdw  AR?RAY syntax
# 2018-04-19 kdw  comments added
# 2018-04-03 kdw  rm () from return
# 2018-03-26 kdw  macro redef
# 2018-03-12 kdw  made PP statements not need semicolon
# 2018-02-19 kdw  secant and macro refactor
# 2018-02-14 kdw  comment change
# 2017-11-26 kdw  FR[O]M and B[Y] keywords
# 2017-11-22 kdw  var renam
# 2017-10-21 kdw  macros start with "at""at"
# 2017-10-20 kdw  COM[M]ENMT format changed
# 2017-10-03 kdw  dont die for bad args
# 2017-08-31 kdw  [pc]dftri, [pc]dfgeo, [pc]dfpoi added
# 2017-08-30 kdw  s/DBL_/DBL/;s/FLT_/FLT/
# 2017-08-20 kdw  rmed/renamd .*_P[E]R_.* vars
# 2017-06-21 kdw  added ";" to COM?MENT lines
# 2017-05-25 kdw  line wrap problem wrt python
# 2017-05-16 kdw  chisqr work
# 2017-04-26 kdw  keyword COMMENT.*
# 2017-04-24 kdw  extra parens added
# 2017-04-21 kdw  var renam
# 2017-04-20 kdw  func to function
# 2017-03-12 kdw  shorten long comments
# 2017-03-10 kdw  get Fw?ip_Pa?rse to work
# 2017-03-07 kdw  INS?ERT etal
# 2017-03-06 kdw  sigils rmed
# 2017-03-01 kdw  RE?TURN syntax more finicky
# 2017-02-28 kdw  REQ?UIRE function ()
# 2017-02-24 kdw  REP?LACE rework, et al
# 2017-02-20 kdw  made die more uniform
# 2017-02-14 kdw  FWIP Loop syntax changed
# 2017-02-13 kdw  FWIP language change
# 2017-02-12 kdw  FWIP language change
# 2017-02-08 kdw  SE[C]ANT syntax
# 2017-02-07 kdw  var renam
# 2017-02-06 kdw  SE[C]ANT syntax
# 2017-02-03 kdw  cdfb?etainv
# 2017-01-31 kdw  beta dist
# 2017-01-06 kdw  ?[?]USE.* to ?[?].*_MODE; ?[?]DIGR.*
# 2017-01-03 kdw  var renam
# 2017-01-02 kdw  Pareto
# 2016-12-23 kdw  die change
# 2016-12-03 kdw  comment change
# 2016-11-27 kdw  long lines
# 2016-11-24 kdw  reformatting of await loops
# 2016-11-22 kdw  moved cdfno?rmal2 to ap?prox and renam
# 2016-11-21 kdw  DE?F to FU?NC
# 2016-11-20 kdw  language change
# 2016-11-18 kdw  _?_P?OD_?_
# 2016-11-16 kdw  comments
# 2016-11-15 kdw  MOD/BIT* syntax change
# 2016-11-14 kdw  seca?nt algorithm refactor
# 2016-11-11 kdw  seca?nt algorithm refactor
# 2016-11-06 kdw  while loop replaced with await
# 2016-11-01 kdw  debugging t-distribution
# 2016-10-31 kdw  EX?ITL?OOP
# 2016-10-30 kdw  lang change
# 2016-09-15 kdw  lang change
# 2016-09-13 kdw  lang change
# 2016-08-15 kdw  layout error
# 2016-07-19 kdw  float numbers (added ".0")
# 2016-05-18 kdw  comment change
# 2015-12-28 kdw  .*2() functions rmed
# 2015-12-28 kdw  _?_I?F_X_?_ to _?_IF_NONE_?_
# 2015-12-26 kdw  commented out _cdf?ks_?1
# 2015-12-16 kdw  long comments
# 2015-12-14 kdw  long lines
# 2015-12-11 kdw  s/LC_// from some consts
# 2015-12-03 kdw  long lines changed
# 2015-12-02 kdw  *student* to *t*
# 2015-11-26 kdw  long lines changed
# 2015-11-19 kdw  long lines changed
# 2015-11-17 kdw  variable rename
# 2015-11-13 kdw  minor refactor; long lines changed
# 2015-11-12 kdw  rmed useless function
# 2015-10-27 kdw  variable rename
# 2015-10-19 kdw  ga[m]ma to tga[m]ma
# 2015-10-09 kdw  renamed i[n]v functions
# 2015-10-01 kdw  float equality checks to is.*
# 2015-09-30 kdw  use p[o]w function
# 2015-09-27 kdw  tweak
# 2015-09-25 kdw  use isodd, iseven instead of [M]OD
# 2015-09-20 kdw  created

# http://www2.econ.osaka-u.ac.jp/(tilde)tanizaki/cv/books
#      /cmse/cmse.pdf
??INSERT_FILE "Macros.fwip"??

FUNC DBL int_pdf(DBL nn, DBL xx):
   # PDF Uniform Integer
   # Support: 0..NN-1
   DBL retvalu;
   DBL mm;

   IF xx < 0.0 OR nn < xx OR NOT isint(xx):
      retvalu = 0.0;
   ELSE: # XX is an integer in [0,NN)
      mm = FLOOR(nn);
      IF Kw.isint(nn):
         IF xx < nn:
            retvalu = 1.0 / nn;
         ELSE:
            retvalu = 0;
         IF_END
      ELSE:
         IF xx < mm:
            retvalu = 1.0 / nn;
         ELSE:
            retvalu = 1.0 - mm / nn;
         IF_END
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL int_cdf(DBL nn, DBL xx):
   # CDF Uniform Integer [0,NN)
   # Support: 0..NN-1
   DBL retvalu;
   DBL mm;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSIF nn <= xx:
      retvalu = 1.0;
   ELSE:
      mm = FLOOR(nn);
      IF xx < mm:
         retvalu = (FLOOR(xx) + 1) / nn;
      ELSE:
         retvalu = 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL int_quantile(DBL nn, DBL prbx):
   # Quantile Uniformly Integer [0,NN)
   # Support: 0..NN-1
   DBL retvalu;

   IF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 - frac(nn) / nn <= prbx:
      retvalu = CEIL(nn - 1);
   ELSE:
      retvalu = FLOOR(nn * prbx + 1);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT int_rand(DBL nn):
   # Random Uniform Integer Variable [0,NN)
   # Support: 0..NN-1
   # Average = FLOOR(NN)*(FLOOR(NN-1)/2+FRAC(NN))/NN
   #    If NN is an integer, average=(NN-1)/2
   INT retvalu;

   IF nn <= 1:
      retvalu = 0;
   ELSE:
      retvalu = FLOORL(randd() * nn);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL normal_pdf(DBL xx):
   # PDF (0,1) gaussian distribution
   # Support: (-Inf,Inf)
   # (-Inf,0,+Inf) to (0,1/SQRT(Kw.TAU),0)
   RETURN EXP(-xx * xx / 2.0) / (SQRT(Kw.TAU));
FUNC_END

FUNC DBL normal_cdf(DBL xx):
   # CDF (0,1) gaussian distribution
   # Support: (-Inf,Inf)
   RETURN Kw.erf(xx / Kw.SQRTTWO) / 2.0 + 0.5;
FUNC_END

FUNC DBL normal_cdf__1(DBL xx):
   # approximate the CDF of the normal distribution
   DBL retvalu;
   DBL sum_curr;
   DBL sum_prev;
   DBL bb;
   DBL xx_sqr;
   DBL ii;

   IF xx <= -10.0:
      retvalu = 0.0;
   ELSIF 10.0 <= xx:
      retvalu = 1.0;
   ELSIF Kw.iszero(xx):
      retvalu = 0.5;
   ELSE:
      sum_curr = 0.0;
      bb = 1.0 / xx;
      xx_sqr = xx * xx;
      AWAIT Kw.iseq(sum_prev, sum_curr) COUNT ii FROM 0:
         bb *= xx_sqr / (2.0 * ii + 1.0);
         sum_prev = sum_curr;
         sum_curr += bb;
      AWAIT_END
      retvalu = (sum_curr * EXP(-0.5 * (xx_sqr + LN(Kw.TAU)))
            + 0.5);
   IF_END
   RETURN retvalu;
FUNC_END
#TEST:normal_cdf__1(1)==0.84134474606854294858523254563203792;

FUNC DBL normal_quantile(DBL prbx):
   # Quantile normal distribution (0,1) to (-Inf,+Inf)
   RETURN Kw.SQRTTWO * Kw.erfinv(2.0 * prbx - 1.0);
FUNC_END

BLOCK: # normal distributed nunmbers
   BLOCK_DEF DBL lv_rand_gau_magic = 0.0;
   BLOCK_DEF DBL lv_rand_gau_prev = 0.0;
   FUNC DBL normal_rand(NUL):
      # Random Normal Variable
      BLOCK_USE lv_rand_gau_magic;
      BLOCK_USE lv_rand_gau_prev;
      DBL retvalu;
      DBL uua;
      DBL uub;
      DBL ww;

      IF Kw.ismagic(lv_rand_gau_magic):
         lv_rand_gau_magic = Kw.magicnot();
         retvalu = lv_rand_gau_prev;
      ELSE:
         AWAIT Kw.isbetweenx(ww, 0.0, 0.25):
            uua = randd() - 0.5;
            uub = randd() - 0.5;
            ww = uua * uua + uub * uub;
         AWAIT_END
         ww = SQRT(-2.0 * LN(4.0 * ww) / ww);
         lv_rand_gau_prev = uub * ww;
         lv_rand_gau_magic = Kw.magicset();
         retvalu = uua * ww;
      IF_END
      RETURN retvalu;
   FUNC_END
BLOCK_END  # normal distributed nunmbers

FUNC DBL gau_pdf(DBL xx):
   # PDF gaussian distribution
   # (-Inf,0,+Inf) to (0,1/SQRT(Kw.TAU),0)
   RETURN normal_pdf(xx);
FUNC_END

FUNC DBL gau_cdf(DBL xx):
   # CDF (0,1) gaussian distribution
   # Support: (-Inf,Inf)
   RETURN normal_cdf(xx);
FUNC_END

FUNC DBL gau_quantile(DBL prbx):
   # Quantile normal ditribution (0,1) to (-Inf,+Inf)
   RETURN normal_quantile(prbx);
FUNC_END

FUNC DBL gau_rand(NUL):
   # Random Normal Variable
   RETURN normal_rand();
FUNC_END

FUNC DBL normal_quantile__1(DBL prbx):
   # Quantile normal ditribution (0,1) to (-Inf,+Inf)
   DBL retvalu;
   DBL p_low;
   DBL qq;
   DBL rr;
   DBL denom;
   DBL numer;
   #Define work variables

   #Define break-point
   p_low = 0.02425;

   IF prbx <= 0.0:
      retvalu = -(Kw.DBLMAX);
   ELSIF 1.0 <= prbx:
      retvalu = Kw.DBLMAX;
   ELSIF p_low <= prbx AND prbx <= 1.0 - p_low: # mid region
      qq = prbx - 0.5;
      rr = qq * qq;
      numer = ((((((
            - 3.96968302866538E+1) * rr
            + 2.20946098424521E+2) * rr
            - 2.75928510446969E+2) * rr
            + 1.38357751867269E+2) * rr
            - 3.06647980661472E+1) * rr
            + 2.50662827745924E+0);

      denom = ((((((
            - 5.44760987982241E+1) * rr
            + 1.61585836858041E+2) * rr
            - 1.55698979859887E+2) * rr
            + 6.68013118877197E+1) * rr
            - 1.32806815528857E+1) * rr
            + 1.00000000000000E+0);

      retvalu = (qq * numer / denom);
   ELSE:
      IF prbx < p_low:      # lower region
         rr = SQRT(-2.0 * LN(prbx));
         qq = 1.0;
      ELSE:  # not lower region
         rr = SQRT(-2.0 * LN(1 - prbx));
         qq = -1.0;
      IF_END
      numer = ((((((
            - 7.78489400243029E-3) * rr
            - 3.22396458041136E-1) * rr
            - 2.40075827716184E+0) * rr
            - 2.54973253934373E+0) * rr
            + 4.37466414146497E+0) * rr
            + 2.93816398269878E+0);

      denom = (((((
            + 7.78469570904146E-3) * rr
            + 3.22467129070040E-1) * rr
            + 2.44513413714300E+0) * rr
            + 3.75440866190742E+0) * rr
            + 1.00000000000000E+0);

      retvalu = qq * numer / denom;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_pdf(DBL max_x, DBL xx):
   # PDF uniform distribution on [0,MAX_X)
   # MEAN       MAX_X / 2
   # VARIANCE   MAX_X / 12
   # MODE       [0,MAX_X)
   # MEDIAN     MAX_ / 2
   DBL retvalu;

   IF max_x <= 0.0 OR xx <= 0.0 OR max_x <= xx:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / max_x;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_cdf(DBL max_x, DBL xx):
   # CDF uniform distribution on [0,MAX_X)
   # Support: [0,MAX_X)
   # MEAN       MAX_X / 2
   # VARIANCE   MAX_X / 12
   # MODE       [0,MAX_X)
   # MEDIAN     MAX_X / 2
   DBL retvalu;

   IF max_x <= 0.0 OR xx < 0.0:
      retvalu = 0.0;
   ELSIF max_x < xx:
      retvalu = 1.0;
   ELSE:
      retvalu = xx / max_x;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_quantile(DBL max_x, DBL prbx):
   # Quantile uniform distribution on [0,MAX_X)
   # Support: [0,MAX_X)
   DBL retvalu;

   IF prbx < 0.0 OR max_x <= 0.0:
      retvalu = 0.0;
   ELSIF max_x < prbx:
      retvalu = 1.0;
   ELSE:
      retvalu = prbx * max_x;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL uni_rand(DBL max_x):
   # Random uniform variable on [0,MAX_X)
   # Support: [0,MAX_X)
   RETURN uni_quantile(max_x, randd());
FUNC_END
#TEST:rand_init(1.987)==1.987;
#TEST:uni_rand(1.0)-0.2159134211342970495126070140656793228118;
#TEST:uni_rand(1.0)-0.9505410465129708504072869601486672763713;
#TEST:uni_rand(1.0)-0.6972580030927504803756056261931917106267;

FUNC DBL exp_pdf(DBL scal, DBL xx):
   # PDF exponential distribution on w/ scaling 0 < SCAL
   # Support: [0,Inf)
   # == SCAL * EXP(-SCAL * XX)
   # MEAN       1 / SCAL
   # VARIANCE   1 / SCAL**2
   # MODE       0
   # MEDIAN     LN(2) / SCAL
   DBL retvalu;

   IF xx < 0.0 OR scal <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = scal * EXP(-scal * xx);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL exp_cdf(DBL scal, DBL xx):
   # CDF exponential distribution w/ scaling 0 < SCAL
   # Support: [0,Inf)
   # == 1 - EXP(-SCAL * XX)
   # MEAN       1 / SCAL
   # VARIANCE   1 / SCAL**2
   # MODE       0
   # MEDIAN     LN(2) / SCAL
   DBL retvalu;

   IF xx < 0.0 OR scal <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 - EXP(-scal * xx);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL exp_quantile(DBL scal, DBL prbx):
   # Quantile exponential ditribution [0,+Inf] to [0,1]
   # == -LN(1 - PRBX) / SCAL
   DBL retvalu;

   IF prbx <= 0.0 OR scal <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = Kw.DBLMAX;
   ELSE:
      retvalu = -LN(1.0 - prbx) / scal;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL exp_rand(DBL scal):
   # Random Exponential Variable
   RETURN -LN(randd()) / scal;
FUNC_END

FUNC DBL poi_pdf(DBL meanx, DBL xx):
   # PDF poisson distribution
   # Support: [0,+Inf)
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   DBL kk;
   DBL retvalu;

   IF xx < 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSE:
      kk = FLOOR(xx);
      retvalu = POW(meanx, kk) * EXP(-meanx) / factorial(kk);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL poi_cdf(DBL meanx, DBL xx):
   # CDF poisson distribution
   # Support: [0,+Inf)
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   INT ii;
   INT kk;
   DBL sum;
   DBL term;
   DBL retvalu;

   IF xx <= 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSIF 1000 < xx / meanx:
      retvalu = 1;#Kw.uigamma(xx, meanx);
   ELSE:
      term = EXP(-meanx);
      sum = term;
      kk = FLOORL(xx);
      FOR ii FROM 1 TO kk:
         term *= meanx / ii;
         sum += term;
      FOR_END
      retvalu = sum;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL poi_quantile(DBL meanx, DBL prbx):
   # Quantile poisson distribution
   # MEAN      MEANX
   # VARIANCE  MEANX
   # MODE      MEANX - 1
   INT ii;
   DBL sum;
   DBL prevsum;
   DBL term;
   DBL retvalu;

   IF prbx <= 0.0 OR meanx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = DBLMAX;
   ELSE:
      prevsum = 0.0;
      term = EXP(-meanx);
      sum = term;
      ii = 0;
      WHILE sum <= prbx:
         ii += 1;
         term *= meanx / ii;
         prevsum = sum;
         sum += term;
      WHILE_END
      IF sum - prbx < prbx - prevsum:
         retvalu = ii;
      ELSE:
         retvalu = ii - 1;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT poi_rand(DBL meanx):
   # Random Poisson variable w/ mean MEANX
   # Support  NN = 0,1,2,3,...
   #   PDFPOI(NN)=MEANX**NN*EXP(-NN)/factorial(NN)
   DBL prob;
   DBL poi;
   DBL sum;
   INT nn;

   prob = randd();
   poi = EXP(-meanx);
   sum = poi;
   nn = 0;
   WHILE sum < prob:
      nn += 1;
      poi *= 1.0 * meanx / nn;
      sum += poi;
   WHILE_END
   RETURN nn;
FUNC_END

FUNC DBL geo_pdf(DBL prob, DBL kk):
   # PDF geometric distribution
   # Support: 0..Inf
   # MEAN      (1 - PROB) / PROB
   # VARIANCE  (1 - PROB) / PROB**2
   # MODE      0
   DBL retvalu;
   IF kk < 0 OR prob < 0.0 OR 1.0 <= prob:
      retvalu = 0.0;
   ELSE:
      retvalu = POW(1.0 - prob, kk) * prob;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL geo_cdf(DBL prob, DBL kk):
   # CDF geometric distribution
   # Support: 0..Inf
   # MEAN      (1 - PROB) / PROB
   # VARIANCE  (1 - PROB) / PROB**2
   # MODE      0
   DBL retvalu;
   IF kk <= -1 OR prob < 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prob:
      retvalu = 1.0;
   ELSE:
      retvalu = 1.0 - POW(1.0 - prob, kk + 1);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL geo_quantile(DBL prob, DBL prbx):
   # Quantile Geometric Distribution
   DBL retvalu;
   IF prbx <= 0.0 OR 1.0 <= prbx OR prob <= 0.0 OR 1.0 <= prob:
      retvalu = 0.0;
   ELSE:
      retvalu = LN(1.0 - prbx) / LN(1.0 - prob) - 1.0;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT geo_rand(DBL prob):
   # Random Geometric Variable
   # Support  0,1,2,3,...
   # THIS IMPLEMENTATION HAS SUPPORT STARTING AT 0
   RETURN FLOORL(LN(randd()) / LN(1.0 - prob));
FUNC_END

FUNC DBL cauchy_pdf(DBL scal, DBL xx):
   # PDF Cauchy distribution w/ scaling 0 < SCAL
   # Support: (-Inf,0,+Inf) to (0,1/Kw.PI,0)
   # MEAN      NAN  (0 principle value)
   # VARIANCE  NAN
   # MODE      0
   # cauchy_pdf(1,x) == t_pdf(1,x)
   RETURN 1.0 / (Kw.PI * scal * (1 + (Kw.square(xx / scal))));
FUNC_END

FUNC DBL cauchy_cdf(DBL scal, DBL xx):
   # CDF Cauchy distribution
   # Support: (-Inf,0,+Inf)
   RETURN taninv(xx / scal) / Kw.PI + 0.5;
FUNC_END

FUNC DBL cauchy_quantile(DBL scal, DBL prbx):
   # Quantile Cauchy distribution
   #      (0,1) to (-Inf,+Inf)
   RETURN scal * TAN((prbx - 0.5) * Kw.PI);
FUNC_END

FUNC DBL cauchy_rand(DBL scal):
   # Random Cauchy Variable
   RETURN cauchy_quantile(scal, randd());
FUNC_END

FUNC DBL logistic_pdf(DBL ss, DBL xx):
   # PDF logistic distribution w/ scaling SS
   # Support: (-Inf,+Inf)
   DBL exs;
   DBL retvalu;

   IF ss <= 0.0:
      retvalu = 0.0;
   ELSE:
      exs = EXP(-xx / ss);

      retvalu = exs / (ss * POW(1.0 + exs, 2.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL logistic_cdf(DBL ss, DBL xx):
   # CDF logistic distribution w/ scaling SS
   # Support: (-Inf,+Inf)
   DBL retvalu;

   IF ss <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (1.0 + EXP(-xx / ss));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL logistic_quantile(DBL ss, DBL prbx):
   # Quantile logistic distribution w/ scaling SS
   DBL retvalu;

   IF prbx <= 0.0 OR ss <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      retvalu = -ss * LN(1.0 / prbx - 1.0);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL logistic_rand(DBL ss):
   # Random Logistic Variable w/ scaling SS
   RETURN -ss * LN(1.0 / randd() - 1.0);
FUNC_END

FUNC DBL tri_pdf(DBL pp, DBL xx):
   # PDF Triangular distribution w/ 0 <= PP <= 1
   # PDF* is triangle defined by (0,0) (1,0) (pp,2)
   # Support: [0,1]
   DBL retvalu;

   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0;
   ELSE:
      IF xx < 0.0 OR 1.0 < xx:
         retvalu = 0.0;
      ELSIF xx < pp:
         retvalu = Kw.divi(2.0 * xx, pp, 2.0);
      ELSE:
         retvalu = Kw.divi(2.0 * (1.0 - xx), 1.0 - pp, 2.0);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL tri_cdf(DBL pp, DBL xx):
   # CDF Triangular distribution
   # Support: [0,1]
   DBL retvalu;

   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0;
   ELSE:
      IF xx <= 0:
         retvalu = 0;
      ELSIF xx < pp:
         retvalu = xx * xx / pp;
      ELSIF xx < 1.0:
         retvalu = 1.0 - Kw.square(1.0 - xx) / (1.0 - pp);
      ELSE:
         retvalu = 1.0;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL tri_quantile(DBL pp, DBL prbx):
   # Quantile Triangular Variable
   DBL retvalu;

   IF pp < 0.0 OR 1.0 < pp:
      retvalu = 0;
   ELSE:
      IF prbx <= 0:
         retvalu = 0;
      ELSIF prbx < pp:
         retvalu = SQRT(prbx * pp);
      ELSIF prbx < 1.0:
         retvalu = 1.0 - SQRT((1.0 - prbx) * (1.0 - pp));
      ELSE:
         retvalu = 1.0;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL tri_rand(DBL pp):
   # Random Triangular Variable
   # Valid only if 0 <= PP <= 1
   # PDF is triangle (0,0) (1,0) and (PP,2)
   DBL xx;
   DBL yy;

   xx = randd();
   yy = randd();
   IF xx < pp:
      IF 2 * xx < pp * yy:
         xx = pp - xx;
      IF_END
   ELSE:
      IF (pp - 1.0) * yy < 2.0 * (xx - 1.0):
         xx = (pp + 1.0) - xx;
      IF_END
   IF_END

   RETURN xx;
FUNC_END

FUNC DBL trap_pdf(DBL para, DBL parb, DBL xx):
   # PDF Trapezoidal Variable
   # Support: [0,1]
   # Must have 0 <= PARA <= PARB  <= 1.0
   # PDF is bounded by (0,0) (1,0), (PARA,HH) and (PARB,HH)
   #   where HH = 2 / (1 + PARB - PARA)
   # Support [0,1]
   # trap_pdf(A,A,) = tri_pdf(A,)
   DBL retvalu;

   IF xx < 0.0 OR 1.0 < xx OR para < 0.0
            OR parb < para OR 1.0 < parb:
      retvalu = 0.0;
   ELSE:
      IF xx < para:
         retvalu = xx / para;
      ELSIF xx <= parb:
         retvalu = 1.0;
      ELSE:
         retvalu = (1.0 - xx) / (1.0 - parb);
      IF_END
   IF_END

   # scale to force area under PDF == 1.0
   RETURN retvalu * 2.0 / (1.0 + parb - para);
FUNC_END

FUNC DBL trap_cdf(DBL para, DBL parb, DBL xx):
   # CDF Trapezoidal Variable
   # Support: [0,1]
   # Must have 0 <= PARA <= PARB <= 1.0
   # PDF is bounded by (0,0) (1,0), (PARA,HH) and (PARB,HH)
   #   where HH = 2 / (1 + PARB - PARA)
   # Support  [0,1]
   DBL mm;
   DBL retvalu;

   IF para < 0.0 OR parb < para OR 1.0 < parb:
      retvalu = 0.0;
   ELSIF xx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= xx:
      retvalu = 1.0;
   ELSE:
      mm = 2.0 / (1.0 + parb - para);
      IF xx < para:
         retvalu = mm * xx * xx / (2.0 * para);
      ELSIF xx < parb:
         retvalu = mm * (xx - para / 2.0);
      ELSE:
         retvalu = 1.0 - mm * Kw.square(1.0 - xx)
               / (2.0 * (1.0 - parb));
      IF_END
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL trap_quantile(DBL para, DBL parb, DBL prbx):
   # Quantile Trapezoidal Variable
   # Must have 0 <= PARA <= PARB <= 1.0
   # PDF is bounded by (0,0) (1,0), (PARA,HH) and (PARB,HH)
   #    where HH = 2 / (1 + PARB - PARA)
   # Support  [0,1]
   DBL mm;
   DBL retvalu;

   IF para < 0.0 OR parb < para OR 1.0 < parb:
      retvalu = 0.0;
   ELSIF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      mm = 2.0 / (1.0 + parb - para);
      IF prbx < para * mm / 2.0:
         retvalu = SQRT((2.0 * para * prbx) / mm);
      ELSIF prbx < 1.0 - mm * (1.0 - parb) / 2.0:
         retvalu = prbx / mm + para / 2.0;
      ELSE:
         retvalu = 1.0 - Kw.SQRTTWO
               * SQRT((1.0 - parb) * (1.0 - prbx) / mm);
      IF_END
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL trap_rand(DBL para, DBL parb):
   # Random Trapezoidal Variable
   # Support  [0,1]
   DBL xx;
   DBL retvalu;

   retvalu = -1;
   AWAIT 0.0 <= retvalu:
      xx = randd();
      IF xx < para:
         IF randd() * para < xx:
            retvalu = xx;
         IF_END
      ELSIF xx <= parb:
         retvalu = xx;
      ELSE:
         IF randd() * (1.0 - parb) < (1.0 - xx):
            retvalu = xx;
         IF_END
      IF_END
   AWAIT_END

   RETURN retvalu;
FUNC_END

FUNC DBL pareto_pdf(DBL shap, DBL scal, DBL xx):
   # PDF Pareto distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support: [0,Inf)
   # == SHAP * (SCAL / XX) ** SHAP / XX
   # MEAN       IF SHAP <= 1, INF
   #            ELSE, SHAP * SCAL / (SHAP - 1)
   # VARIANCE   IF SHAP <= 2, INF
   #         ELSE, SHAP**2 * SCAL / ((SHAP - 1)**2 * (SHAP - 2))
   # MODE       SCAL
   # MEDIAN     SCAL * POW(2, 1 / SHAP)
   RETURN shap * POW(scal / xx, shap) / xx;
FUNC_END

FUNC DBL pareto_cdf(DBL shap, DBL scal, DBL xx):
   # CDF Pareto distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support: [0,Inf)
   # == 1 - (SCAL / XX) ** SHAP
   # MEAN       IF SHAP <= 1, INF
   #            ELSE, SHAP * SCAL / (SHAP - 1)
   # VARIANCE   IF SHAP <= 2, INF
   #         ELSE, SHAP**2 * SCAL / ((SHAP - 1)**2 * (SHAP - 2))
   # MODE       SCAL
   # MEDIAN     SCAL * POW(2, 1 / SHAP)
   RETURN 1.0 - POW(scal / xx, shap);
FUNC_END

FUNC DBL pareto_quantile(DBL shap, DBL scal, DBL prbx):
   # Quantile Pareto distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN scal / POW(1.0 - prbx, 1.0 / shap);
FUNC_END
#TEST:pareto_quantile(1.3,2.4,pareto_cdf(1.3,2.4, 3.5))==3.5;

FUNC DBL pareto_rand(DBL shap, DBL scal):
   # Random Pareto Variable with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN scal / POW(randd(), 1.0 / shap);
FUNC_END

FUNC DBL gompertz_pdf(DBL shap, DBL scal, DBL xx):
   # PDF Gompertz distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support: [0,Inf)
   # MEAN       EXP(SHAP) * Kw.Ei(-SHAP) / SCAL
   # MODE       IF SHAP < 1: -LN(SHAP) / SCAL
   #            ELSE: 0
   # MEDIAN     LN(LN(0.5) / SHAP + 1) / SCAL
   RETURN scal * shap * EXP(shap + scal * xx
            - shap * EXP(scal * xx));
FUNC_END

FUNC DBL gompertz_cdf(DBL shap, DBL scal, DBL xx):
   # CDF gompertz distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   # Support: [0,Inf)
   RETURN 1.0 - EXP(-shap * (EXP(scal * xx) - 1));
FUNC_END

FUNC DBL gompertz_quantile(DBL shap, DBL scal, DBL prbx):
   # Quantile Gompertz distribution with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN LN(1 - LN(1.0 - prbx) / shap) / scal;
FUNC_END
#TEST:gompertz_quantile(1.3,2.4,gompertz_cdf(1.3,2.4,0.7))==0.7;

FUNC DBL gompertz_rand(DBL shap, DBL scal):
   # Random Gompertz Variable with shape 0 < SHAP
   # and scale 0 < SCAL.
   RETURN gompertz_quantile(shap, scal, randd());
FUNC_END

FUNC DBL zipf_pdf(DBL ss, INT max_kk, INT kk):
   # PDF zipf distribution w/ parameter SS over 1..MAX_KK
   DBL retvalu;

   IF kk <= 0.0 OR max_kk < kk:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (POW(kk, ss) * Kw.hnm(max_kk, ss));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL zipf_cdf(DBL ss, INT max_kk, INT kk):
   # CDF zipf distribution w/ parameter SS over 0..MAX_KK
   DBL retvalu;

   IF kk <= 0.0:
      retvalu = 0.0;
   ELSIF max_kk < kk:
      retvalu = 1.0;
   ELSE:
      retvalu = Kw.hnm(kk, ss) / Kw.hnm(max_kk, ss);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT zipf_quantile(DBL ss, INT max_kk, DBL prbx):
   # Inverse Zipf distribution w/ parameter SS
   #    over integers KK in [1,MAX_KK]
   INT ii;
   DBL summ;
   DBL target;

   target = prbx * Kw.hnm(max_kk, ss);
   summ = 0;
   AWAIT target <= summ COUNT ii FROM 1:
      summ += 1.0 / POW(ii, ss);
   AWAIT_END
   RETURN ii;
FUNC_END

FUNC INT zipf_rand(DBL ss, INT max_kk):
   # Random Zipf Variable w/ parameter SS
   #    over integers in [1,MAX_KK]
   RETURN zipf_quantile(ss, max_kk, randd());
FUNC_END

FUNC DBL beta_pdf(DBL shap_a, DBL shap_b, DBL xx):
   # PDF Beta distribution w/ shape 0 < SHAP_A,SHAP_B
   # Support: (-Inf,Inf)
   RETURN POW(xx, shap_a - 1.0) * POW((1.0 - xx), shap_b - 1.0)
            / beta(shap_a, shap_b);
FUNC_END

FUNC DBL beta_cdf(DBL shap_a, DBL shap_b, DBL xx):
   # CDF Beta distribution with shape parameters
   #    0 < SHAP_A and 0 < SHAP_B
   RETURN betainc(shap_a, shap_b, xx);
FUNC_END

FUNC DBL beta_quantile(DBL shap_a, DBL shap_b, DBL prbx):
   # Quantile Beta distribution with shape parameters
   #    0 < SHAP_A and 0 < SHAP_B
   DBL retvalu;
   ??SECANT_DECLARATIONS??

   IF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      ??SECANT_LOOP 0.25 ; 0.50
            ; prbx - beta_cdf(shap_a, shap_b, scvx_xx) ??
      retvalu = scvx_xx;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL beta_rand(DBL shap_a, DBL shap_b):
   # Random Beta Variable w/ shape 0 < SHAP_A,SHAP_B
   RETURN beta_quantile(shap_a, shap_b, randd());
FUNC_END

FUNC DBL gamma_pdf(DBL shap, DBL xx):
   # PDF gamma distribution w/ shape SHAP
   # Support: (0,Inf)
   # MEAN       SHAP
   # VARIANCE   SHAP
   # MODE       SHAP - 1 for 1 <= SHAP
   # MEDIAN     ?
   DBL retvalu;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = EXP(LN(xx) * (shap - 1.0) - xx)
               / Kw.tgamma(shap);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL gamma_cdf(DBL shap, DBL xx):
   # CDF gamma distribution w/ shape SHAP
   # Support: (0,Inf)
   # MEAN       SHAP
   # VARIANCE   SHAP
   # MODE       SHAP - 1 for 1 <= SHAP
   # MEDIAN     ?
   DBL retvalu;
   DBL rr;
   INT ii;
   DBL sum;

   IF xx <= 0.0 OR shap <= 0.0:
      retvalu = 0.0;
   ELSIF Kw.isint(shap):
      sum = 1.0;
      rr = 1.0;
      FOR ii FROM 1 TO shap - 1:
         rr *= xx / ii;
         sum += rr;
      FOR_END
      retvalu = 1.0 - EXP(-xx) * sum;
   ELSE:
      retvalu = Kw.rligamma(shap, xx);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL gamma_rand(DBL shap):
   # Random Gamma Variable w/ shape SHAP
   DBL i_shape;
   DBL f_shape;
   DBL val;
   DBL jj;
   DBL ee;
   DBL gg;
   DBL yy;
   DBL ff;
   DBL xx;
   DBL vv;
   DBL qq;
   DBL pp;

   i_shape = FLOOR(shap);
   val = 1.0;
   IF shap < 5:
      FOR jj FROM 1 TO i_shape:
         val *= randd();
      FOR_END
      val = -LN(val);
      f_shape = shap - i_shape;
      IF 0.00001 < f_shape:
         # from "The Art of Computer Programming"
         # Volume 2 1997 by Donald Knuth, Page 587
         pp = Kw.E / (f_shape + Kw.E);
         AWAIT randd() < qq:
            vv = LN(randd());
            IF randd() < pp:
               xx = EXP(vv / f_shape);
               qq = EXP(-xx);
            ELSE:
               xx = 1.0 - vv;
               qq = EXP(LN(xx) * (f_shape - 1));
            IF_END
         AWAIT_END
         val += xx;
      IF_END
   ELSE:
      # from "The Art of Computer Programming"
      # Volume 2 1997 by Donald Knuth, Page 134
      ee = shap - 1.0;
      gg = SQRT(shap + ee);
      yy = 0.0;
      ff = 0.0;
      WHILE val <= 0.0 OR (1.0 + yy * yy)
               * EXP(ee * LN(val / ee) - ff) < randd():
         xx = Kw.PI * randd();
         yy = SIN(xx) / COS(xx);
         ff = gg * yy;
         val = ff + ee;
      WHILE_END
   IF_END
   RETURN val;
FUNC_END

FUNC DBL chisqr_pdf(DBL df, DBL xx):
   # PDF Chi-square distribution
   # Support: (0,Inf)
   # MEAN       DF
   # VARIANCE   2 * DF
   # MODE       MAX(DF - 2, 0)
   # MEDIAN     about DF * (1 - 2 / (9 * DF**2))
   DBL retvalu;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = (EXP((LN(xx / 2.0) * df - xx) / 2.0)
         / (xx * Kw.tgamma(df / 2.0)));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL chisqr_cdf(DBL df, DBL xx):
   # CDF Chi-square distribution
   # Support: (0,Inf)
   # MEAN       DF
   # VARIANCE   2 * DF
   # MODE       MAX(DF - 2, 0)
   # MEDIAN     about DF * (1 - 2 / (9 * DF**2))
   DBL retvalu;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = (1.0 - Kw.ruigamma(df / 2.0, xx / 2.0));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL chisqr_rand(DBL df):
   # Random Chi-squared Variable w/ DF
   DBL sum;
   DBL vv;
   DBL jj;

   sum = 0;
   FOR jj FROM 1 TO df:
      vv = gau_rand();
      sum += vv * vv;
   FOR_END
   IF NOT Kw.isint(df):
      sum += gamma_rand(frac(df) / 2.0) * 2.0;
   IF_END
   RETURN sum;
FUNC_END

FUNC DBL binomial_pdf(DBL prob, INT success, INT trial):
   # PDF binomial distribution
   # Support: 0..SUCCESS
   DBL retvalu;
   IF success < 0 OR trial < success:
      retvalu = 0.0;
   ELSE:
      retvalu = comb(trial, success)
         * POW(prob, success)
         * POW(1.0 - prob, trial - success);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL binomial_cdf(DBL prob, INT success, INT trial):
   # CDF binomial distribution
   # Support: 0..SUCCESS
   # Must have  0 <= PROB <= 1 ; SUCCESS <= TRIAL
   #  == betainc(TRIAL - SUCCESS, SUCCESS + 1.0, 1.0 - PROB)
   DBL lsum;
   DBL sfactor;
   INT ss;
   DBL mu;
   DBL kk;

   IF prob <= 0.0 OR success < 0:
      lsum = 0.0;
   ELSIF 1.0 <= prob OR trial <= success:
      lsum = 1.0;
   ELSE:
      # Use binomial_cdf(PR,K,N) = binomial_cdf(1-PR,N-K-1,N)
      IF trial <= 2 * success:
         ss = trial - success - 1;
         prob = 1.0 - prob;
      ELSE:
         ss = success;
      IF_END

      sfactor = POW(1.0 - prob, trial);
      mu = prob / (1.0 - prob);
      lsum = 0.0;
      FOR kk FROM 0 TO ss:
         lsum += sfactor;
         sfactor *= (mu * (trial - kk)) / (kk + 1.0);
      FOR_END

      IF ss <> success:
         lsum = 1.0 - lsum;
      IF_END
   IF_END
   RETURN lsum;
FUNC_END

FUNC DBL binomial_rand(DBL prob, DBL rr):
   # Random Binomial Variable
   # count of successes with probability PROB in RR trials
   DBL successes;

   successes = 0;
   WHILE 0 < rr:
      IF randd() < prob:
         successes += 1;
      IF_END
      rr -= 1;
   WHILE_END
   RETURN successes;
FUNC_END

FUNC DBL benford_pdf(INT max_kk, INT kk):
   # PDF Benford distribution aka "First-digit law"
   # Support: 1..MAX_KK-1
   # == LN(1 + 1 / KK) / LN(MAX_KK)
   DBL retvalu;

   IF kk <= 0.0 OR max_kk <= kk:
      retvalu = 0.0;
   ELSE:
      retvalu = LN(1.0 + 1.0 / kk) / LN(max_kk);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL benford_cdf(INT max_kk, INT kk):
   # CDF Benford distribution aka "First-digit law"
   # Support: 1..MAX_KK-1
   # == LN(KK + 1) / LN(MAX_KK)
   DBL retvalu;

   IF kk <= 0.0:
      retvalu = 0.0;
   ELSIF max_kk <= kk:
      retvalu = 1.0;
   ELSE:
      retvalu = LN(kk + 1.0) / LN(max_kk);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC INT benford_rand(INT max_kk):
   # Random Benford Variable over [1,MAX_KK)
   # aka "First-digit law"
   INT ii;
   DBL summ;
   DBL target;

   target = randd();
   summ = 0;
   AWAIT target <= summ COUNT ii FROM 1:
      summ += LN(1.0 + 1.0 / ii) / LN(max_kk);
   AWAIT_END
   RETURN ii;
FUNC_END

FUNC DBL nbd_pdf(DBL prob, INT rsuccesses, INT kfailures):
   # PDF Negative Binomial Distribution with
   #    success probability PROB, RSUCCESSES successes,
   #    and KFAILURES failures.
   # Support: 0..Inf
   # return probability that the RSUCCESESth success
   #    is on the (KFAILURES + RSUCCESSES)th trial
   #    given probability of success == PROB
   RETURN comb(rsuccesses + kfailures - 1, kfailures)
         * POW(1.0 - prob, kfailures) * POW(prob, rsuccesses);
FUNC_END

FUNC DBL nbd_cdf(DBL prob, INT rsuccesses, INT kfailures):
   # CDF Negative Binomial Distribution with
   #    success probability PROB, RSUCCESSES successes,
   #    and KFAILURES failures.
   # Support: 0..Inf
   # return probability that the RSUCCESESth success
   #    occurs before the (KFAILURES + RSUCCESSES + 1 )th trial
   #    given probability of success == PROB
   RETURN 1.0 - betainc(kfailures + 1, rsuccesses, 1.0 - prob);
FUNC_END

FUNC INT nbd_rand(DBL prob, INT rsuccesses):
   # Random Negative Binomial Variable
   # Return number of failures before the RSUCCESSESth
   #     success given probability of success == PROB
   # support is integers in [0,+Inf)
   INT failures;
   INT rr;

   rr = rsuccesses;
   failures = 0;
   WHILE 0 < rr:
      IF randd() <= prob:
         rr -= 1;   # success
      ELSE:
         failures += 1;   # failure
      IF_END
   WHILE_END

   RETURN failures;
FUNC_END

FUNC DBL polya_pdf(DBL prob, DBL rsuccesses, DBL kfailures):
   RETURN combx(rsuccesses + kfailures - 1, kfailures)
         * POW(1.0 - prob, kfailures) * POW(prob, rsuccesses);
FUNC_END

FUNC DBL polya_cdf(DBL prob, DBL rsuccesses, DBL kfailures):
   RETURN 1.0 - betainc(kfailures + 1, rsuccesses, 1.0 - prob);
FUNC_END

FUNC DBL polya_rand(DBL tt, DBL prob):
   # Random Polya Variable
   # a real extension of negative binomial distribution
   DBL nn;
   DBL mm;
   DBL rr;
   INT uu;
   DBL qq;

   nn = 0;
   mm = tt - 1;
   qq = EXP(tt * LN(prob));
   rr = qq;
   uu = randd();

   WHILE rr <= uu:
      nn += 1;
      mm += 1;
      qq *= (1.0 - prob) * mm / nn;
      rr += qq;
   WHILE_END

   RETURN nn;
FUNC_END

FUNC DBL zeta_pdf(DBL ss, INT xx):
   # PDF zeta distribution w/ parameter SS
   # Support: 0..Inf
   DBL retvalu;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (Kw.zeta(ss) * POW(xx, ss));
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL zeta_cdf(DBL ss, INT xx):
   # CDF zeta distribution w/ parameter SS
   # Support: 1..Inf
   DBL retvalu;

   IF xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = Kw.hnm(xx, ss) / Kw.zeta(ss);
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL ks_cdf(INT nn, DBL xx):
   # CDF Kolmogorov-Smirnov distribution
   # from "The Art of Computer Programming" by D. E. Knuth
   # Volume 2 3ed. Pg 58 and 561
   DBL retvalu;
   DBL two_tt_sqr;
   INT kk;
   DBL sum;
   DBL tt;

   IF nn <= 0 OR xx <= 0.0:
      retvalu = 0.0;
   ELSE:
      IF 30 < nn:
         tt = xx;
         two_tt_sqr = 2.0 * tt * tt;
         retvalu = 1.0 - EXP(-two_tt_sqr)
            * (1.0 - 2.0 * tt / (3.0 * SQRT(nn))
            - two_tt_sqr * (two_tt_sqr / 9.0 - 1.0 / 3.0) / nn);
      ELSE:
         tt = xx * SQRT(nn);
         sum = 0.0;
         kk = nn;
         WHILE tt < kk:
            sum += Kw.comb(nn, kk) * POW(kk - tt, kk)
                     * POW(tt + nn - kk, nn - kk - 1);
            kk -= 1;
         WHILE_END
         retvalu = 1.0 - sum * tt / POW(nn, nn);
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL ks_a_cdf(DBL xx):
   # from https://en.wikipedia.org/wiki/ Kolmogorov-Smirnov_test
   #      Pr(K <= XX) = ks_a_cdf(XX)
   # where K is a Kolmogorov Distribution
   DBL sum;
   DBL sum_prev;
   DBL vv;
   INT kk;
   DBL retvalu;

   IF xx < 0.0001:
      retvalu = 0.0;
   ELSE:
      sum = 0.0;
      vv = -Kw.square(Kw.PI / xx) / 8.0;

      AWAIT Kw.iseq(sum, sum_prev) COUNT kk FROM 1 BY 2:
         sum_prev = sum;
         sum += EXP(vv * kk * kk);
      AWAIT_END
      retvalu = sum * SQRT(Kw.TAU) / xx;
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL ks_b_cdf(INT nn, DBL xx):
   # from https://en.wikipedia.org/wiki/ Kolmogorov-Smirnov_test
   # Thin wrapper around ks_a_cdf where XX is replaced with
   #   XX + 1 / (6 * sqrt(NN)) + (XX - 1) / (4 * NN)
   DBL retvalu;
   DBL nxx;

   IF xx < 0.0001 OR nn <= 0:
      retvalu = 0.0;
   ELSE:
      nxx = xx + (2.0 * SQRT(nn) + 3.0 * xx - 3.0) / (12.0 * nn);
      retvalu = ks_a_cdf(nxx);
   IF_END

   RETURN retvalu;
FUNC_END

FUNC DBL ks_quantile(DBL nn, DBL prbx):
   # Quantile Kolmogorov-Smirnov distribution
   ??SECANT_DECLARATIONS??
   IF NOT Kw.isbetween(prbx, 0.0, 1.0):
      scvx_xx = 0.0;
   ELSE:
      ??SECANT_LOOP 0.25 ; 0.5 ; prbx - ks_cdf(nn, scvx_xx) ??
   IF_END
   RETURN scvx_xx;
FUNC_END

FUNC DBL t_pdf(DBL dfn, DBL xx):
   # PDF Students T Distribution
   RETURN Kw.tgamma((dfn + 1.0) / 2.0)
         * POW((1.0 + Kw.square(xx) / dfn), (-(dfn + 1.0) / 2.0))
         / (SQRT(dfn * Kw.PI) * Kw.tgamma(dfn / 2.0));
FUNC_END

BLOCK: # define t_cdf
   BLOCK_DEF FUNC DBL lf_subtprob(DBL nnx, DBL xx):
      DBL aa;
      DBL bb;
      DBL ww;
      DBL zz;
      DBL yy;
      DBL ii;
      INT nn;
      DBL retvalu;

      nn = FLOORL(ABS(nnx));

      ww = ATAN2(xx, SQRT(nn));
      zz = Kw.square(COS(ww));
      yy = 1.0;

      ii = nn - 2.0;
      WHILE 2.0 <= ii:
         yy = 1.0 + (ii - 1.0) / ii * zz * yy;
         ii -= 2.0;
      WHILE_END

      IF Kw.iseven(nn):
         aa = SIN(ww) / 2.0;
         bb = 0.5;
      ELSE:
         IF nn == 1:
            aa = 0;
         ELSE:
            aa = SIN(ww) * COS(ww) / Kw.PI;
         IF_END

         bb = 0.5 + ww / Kw.PI;
      IF_END

      retvalu = bb + aa * yy;
      IF 1.0 < retvalu:
         retvalu = 1.0;
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL t_cdf(DBL dfx, DBL xx):
      # CDF Students T distribution
      RETURN lf_subtprob(dfx, xx);
   FUNC_END
BLOCK_END # define t_cdf

BLOCK:
   BLOCK_DEF FUNC DBL lf_t_quantile(INT ndfx, DBL prbx):
      # Quantile Students T distribution
      DBL ux;
      DBL uxsq;
      DBL aa_x;
      DBL bb_x;
      DBL cc_x;
      DBL dd_x;
      DBL ee_x;
      DBL retvalu;
      DBL delta;
      DBL pp_a;
      DBL nn_a;
      DBL out_sign;

      IF prbx < 0.5:
         prbx = 1.0 - prbx;
         out_sign = -1;
      ELSE:
         out_sign = 1;
      IF_END
      ux = normal_quantile(prbx);# 20121022 kdpw lf_subu(prbx);
      uxsq = Kw.square(ux);

      aa_x = ((
            + 1.0) * uxsq
            + 1.0) / 4.0;
      bb_x = (((
            + 5.0) * uxsq
            + 16.0) * uxsq
            + 3.0) / 96.0;
      cc_x = ((((
            + 3.0) * uxsq
            + 19.0) * uxsq
            + 17.0) * uxsq
            - 15.0) / 384.0;
      dd_x = (((((
            + 79.0) * uxsq
            + 776.0) * uxsq
            + 1482.0) * uxsq
            - 1920.0) * uxsq
            - 945.0) / 92160.0;
      ee_x = ((((((
            + 27.0) * uxsq
            + 339.0) * uxsq
            + 930.0) * uxsq
            - 1782.0) * uxsq
            - 765.0) * uxsq
            - 17955.0) / 368640.0; # 20200407 kdw  changed sign

      retvalu = ux * (1.0 + (aa_x + (bb_x + (cc_x + (dd_x
         + ee_x / ndfx) / ndfx) / ndfx) / ndfx) / ndfx);

      IF ndfx <= Kw.square(Kw.log10(prbx)) + 3.0:
         nn_a = ndfx + 1.0;
         AWAIT Kw.iszero(retvalu) OR aa_x < retvalu:
            pp_a = lf_subtprob(ndfx, retvalu);
            ee_x = (nn_a * LN(nn_a / (ndfx + Kw.square(retvalu)))
                  + LN(ndfx / nn_a / Kw.TAU) - 1.0
                  + (1.0 / nn_a - 1.0 / ndfx) / 6.0) / 2.0;
            IF 100 < ee_x: # prevent overflow in exp
               delta = 0;
            ELSE:
               delta = (pp_a - prbx) / EXP(ee_x);
            IF_END
            retvalu -= delta;
            # reuse aa_x
            aa_x = ABS(delta) * 10000.0;
         AWAIT_END
      IF_END
      RETURN out_sign * retvalu;
   FUNC_END

   FUNC DBL t_quantile(DBL dfx, DBL prbx):
      # Quantile Students T distribution
      INT ndfx;
      DBL retvalu;

      ndfx = FLOOR(ABS(dfx));

      IF Kw.iszero(prbx - 0.5):
         retvalu = 0.0;
      ELSIF prbx <= 0.0:
         retvalu = - Kw.DBLMAX;
      ELSIF 1.0 <= prbx:
         retvalu = Kw.DBLMAX;
      ELSE:
         retvalu = lf_t_quantile(ndfx, prbx);
      IF_END

      RETURN retvalu;
   FUNC_END
BLOCK_END # define t_quantile()

FUNC DBL t_cdf__1(DBL dfx, DBL xx):
   # CDF Students T distribution
   DBL zz;
   DBL yy;

   yy = SQRT(dfx + xx * xx);
   zz = (xx + yy) / (2.0 * yy);
   RETURN Kw.betainc__1(dfx / 2.0, dfx / 2.0, zz);
FUNC_END

FUNC DBL t_quantile__1(DBL dfx, DBL prbx):
   # Quantile Students T distribution
   ??SECANT_DECLARATIONS??
   IF NOT Kw.isbetween(prbx, 0.0, 1.0):
      scvx_xx = 0.0;
   ELSE:
      ??SECANT_LOOP 0.25 ; 0.5 ; prbx - t_cdf(dfx, scvx_xx) ??
   IF_END
   RETURN scvx_xx;
FUNC_END

FUNC DBL f_cdf(INT dfn_a, INT dfn_b, DBL xx):
   # CDF Fisher-Senecords Distribution
   DBL aa;
   DBL bb;
   DBL gg;

   aa = dfn_a / 2.0;
   bb = dfn_b / 2.0;
   gg = aa * xx;

   RETURN beta_cdf(aa, bb, gg / (bb + gg));
FUNC_END

BLOCK:
   BLOCK_DEF FUNC DBL lf_subfprob(INT dfn_a, INT dfn_b, DBL xx):
      DBL retvalu;
      DBL zx;
      DBL ax;
      DBL bx;
      DBL yx;
      DBL ix;
      DBL pp_a;

      IF xx <= 0.0:
         retvalu = 1.0;
      ELSIF Kw.iseven(dfn_b):
         zx = dfn_b / (dfn_b + dfn_a * xx);
         ax = 1.0;
         FOR ix FROM dfn_b - 2 TO 2 BY -2:
            ax = 1.0 + (dfn_a + ix - 2.0) / ix * zx * ax;
         FOR_END
         retvalu = 1.0 - (POW(1.0 - zx, dfn_a / 2.0) * ax);
      ELSIF Kw.iseven(dfn_a):
         zx = dfn_a * xx / (dfn_b + dfn_a * xx);
         ax = 1.0;
         FOR ix FROM dfn_a - 2 TO 2 BY -2:
            ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
         FOR_END
         retvalu = POW(1.0 - zx, dfn_b / 2.0) * ax;
      ELSE:
         yx = ATAN2(SQRT(dfn_a * xx / dfn_b), 1.0);
         zx = Kw.square(SIN(yx));
         IF dfn_a == 1:
            ax = 0.0;
         ELSE:
            ax = 1.0;
         IF_END
         FOR ix FROM dfn_a - 2 TO 3 BY -2:
            ax = 1.0 + (dfn_b + ix - 2.0) / ix * zx * ax;
         FOR_END
         bx = Kw.PI;
         FOR ix FROM 2 TO dfn_b - 1 BY 2:
            bx *= (ix - 1.0) / ix;
         FOR_END
         pp_a = 2.0 / bx * SIN(yx) * POW(COS(yx), dfn_b) * ax;

         zx = Kw.square(COS(yx));
         IF dfn_b == 1:
            ax = 0.0;
         ELSE:
            ax = 1.0;
         IF_END
         FOR ix FROM dfn_b - 2 TO 3 BY -2:
            ax = 1.0 + (ix - 1.0) / ix * zx * ax;
         FOR_END
         retvalu = (pp_a + 1.0
            - (4.0 / Kw.TAU) * (yx + SIN(yx) * COS(yx) * ax));
         IF retvalu < 0.0:
            retvalu = 0.0;
         IF_END
      IF_END
      RETURN retvalu;
   FUNC_END

   BLOCK_DEF FUNC DBL lf_subf_two(DBL nx, DBL mm, DBL pp):
      DBL uu;
      DBL nx_sub_two;
      DBL xx_prev;
      DBL xx;
      DBL zz;

      uu = chisqr_cdf(nx, pp);
      nx_sub_two = nx - 2.0;
      xx = (uu / nx
         * (1.0
         + ((uu - nx_sub_two) / 2.0
            + (((4.0 * uu - 11.0 * nx_sub_two) * uu
               + nx_sub_two * (7.0 * nx - 10.0)) / 24.0
            + (((2.0 * uu - 10.0 * nx_sub_two) * uu
               + nx_sub_two * (17.0 * nx - 26.0)) * uu
            - nx_sub_two * nx_sub_two * (9.0 * nx - 6.0)) / 48.0
         / mm) / mm) / mm));

      AWAIT Kw.iswithin(xx, xx_prev, 0.00001):
         IF xx <= 0.0:
            AWAIT_EXIT;
         IF_END
         zz = EXP(
            ((nx + mm) * LN((nx + mm) / (nx * xx + mm))
               + (nx - 2.0) * LN(xx)
               + LN(nx * mm / (nx + mm))
               - Kw.LNTWO - LN(Kw.TAU)
               - (1.0 / nx + 1.0 / mm - 1.0 / (nx + mm)) / 6.0
            ) / 2.0);
         xx_prev = xx;
         xx += (lf_subfprob(nx, mm, xx) - pp) / zz;
      AWAIT_END
      RETURN xx;
   FUNC_END

   BLOCK_DEF FUNC DBL lf_subfx(INT nx, INT mm, DBL pp):
      DBL retvalu;
      DBL uu;
      DBL aa;

      IF Kw.iseq(pp, 1.0):
         retvalu = 0.0;
      ELSIF mm == 0:
         retvalu = 1.0 / Kw.square(t_quantile(nx
               , 0.5 - pp / 2.0));
      ELSIF nx == 1:
         retvalu = Kw.square(t_quantile(mm, pp / 2.0));
      ELSIF mm == 2:
         uu = chisqr_cdf(mm, 1.0 - pp);
         aa = mm - 2.0;
         retvalu = 1.0 / (uu / mm * (1.0
            + ((uu - aa) / 2.0
            + (((4.0 * uu - 11.0 * aa) * uu
               + aa * (7.0 * mm - 10.0)) / 24.0
            + (((2.0 * uu - 10.0 * aa) * uu
               + aa * (17.0 * mm - 26.0)) * uu
            - aa * aa * (9.0 * mm - 6.0)
            ) / 48.0 / nx) / nx) / nx));
      ELSIF mm < nx:
         retvalu = 1.0 / lf_subf_two(mm, nx, 1.0 - pp);
      ELSE:
         retvalu = lf_subf_two(nx, mm, pp);
      IF_END
      RETURN retvalu;
   FUNC_END

   FUNC DBL f_quantile(INT dfn_a, INT dfn_b, DBL prbx):
      # Quantile Fisher-Senecords Distribution
      RETURN lf_subfx(dfn_a, dfn_b, 1.0 - prbx);
   FUNC_END
BLOCK_END

FUNC DBL f_quantile__1(INT dfn_a, INT dfn_b, DBL prbx):
   DBL retvalu;
   ??SECANT_DECLARATIONS??

   IF prbx <= 0.0:
      retvalu = 0.0;
   ELSIF 1.0 <= prbx:
      retvalu = 1.0;
   ELSE:
      ??SECANT_LOOP 0.25 ; 0.50
            ; prbx - f_cdf(dfn_a, dfn_b, scvx_xx) ??
      retvalu = scvx_xx;
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL mb_pdf(DBL aa, DBL xx):
   # PDF Maxwell-Boltzmann distribution
   RETURN SQRT(4 / Kw.TAU) * xx * xx
         * EXP(-xx * xx / (2 * aa * aa)) / (aa * aa * aa);
FUNC_END

FUNC DBL mb_cdf(DBL aa, DBL xx):
   # CDF Maxwell-Boltzmann distribution
   # MEAN = 2 * aa * SQRT(4 / TAU)
   # MODE = SQRT(2) * aa
   # VARIANCE = aa * aa * (3 - 16 / TAU)
   # Let aa = SQRT(BOLTZMANN * temperature / mass)
   # or     = SQRT(GAS * temperature / molar-mass)
   RETURN Kw.erf(xx / (Kw.SQRTTWO * aa)) - SQRT(4 / Kw.TAU) * xx
         * EXP(-xx * xx / (2 * aa * aa)) / aa;
FUNC_END

FUNC DBL maxwell_boltzmann_pdf(DBL temperature
      , DBL molecular_mass, DBL velocity):
   # PDF Maxwell-Boltzmann distribution
   DBL aa;

   aa = SQRT(Kw.BOLTZMANN * temperature / molecular_mass);
   RETURN mb_pdf(aa, velocity);
FUNC_END

FUNC DBL maxwell_boltzmann_cdf(DBL temperature
      , DBL molecular_mass, DBL velocity):
   # CDF Maxwell-Boltzmann distribution
   # Lat AA = sqrt(BOLTZMANN * TEMPERATURE / MASS)
   # MEAN     = 4 * AA / SQRT(TAU)
   # MODE     = AA * SQRT(2)
   # VARIANCE = AA**2 * (3 - 16 / TAU)
   DBL aa;

   aa = SQRT(Kw.BOLTZMANN * temperature / molecular_mass);
   RETURN mb_cdf(aa, velocity);
FUNC_END

FUNC DBL maxwell_juttner_pdf(DBL temperature
      , DBL molecular_mass, DBL velocity):
   # PDF Maxwell-Juttner distribution
   DBL gmm;
   DBL bt;
   DBL rtht;
   DBL dn;
   DBL retvalu;

   IF temperature <= 0.0
            OR velocity <= 0.0 OR Kw.LIGHT <= velocity
            OR molecular_mass <= 0.0:
      retvalu = 0.0;
   ELSE:
      rtht = (molecular_mass * Kw.LIGHT * Kw.LIGHT)
               / (Kw.BOLTZMANN * temperature);
      bt = velocity / Kw.LIGHT;
      gmm = 1.0 / Kw.topyh1(bt);
      dn = Kw.bessKn(2, rtht);
      IF Kw.iszero(dn):
         retvalu = 0.0;
      ELSE:
         retvalu = gmm * gmm * bt * rtht * EXP(-gmm * rtht) / dn;
      IF_END
   IF_END
   RETURN retvalu;
FUNC_END

FUNC DBL bb_pdf(DBL wavelen):
   # PDF black-body distribution over [0,Inf)
   # output is spectral radiance which has units of
   #    Power / Area / length
   # MODE   1 / (wp(-5 * exp(-5)) + 5) == 0.201405235272642
   DBL retvalu;

   IF wavelen <= 0.0:
      retvalu = 0.0;
   ELSE:
      retvalu = 1.0 / (POW(wavelen, 5.0)
            * (EXP(1.0 / wavelen) - 1.0));
   IF_END

   RETURN retvalu * 15.0 / POW(Kw.PI, 4.0);
FUNC_END

FUNC DBL blackbody_pdf(DBL wavelen):
   # PDF black-body distribution over [0,Inf)
   # output is spectral radiance which has units of
   #    Power / Area / length
   RETURN bb_pdf(wavelen);
FUNC_END

FUNC INT ints_rand(INT nn, READONLY DBL prob_arr_pc[]):
   # random number in [0,NN) with
   #   p(MM) = PROB_ARR_PC[MM] / SUM(PROB_ARR_PC[])
   DBL sum;
   INT p_ind;
   DBL rndm;
   DBL hh;

   sum = 0;

   FOR p_ind FROM 0 TO nn - 1:
      sum += prob_arr_pc[p_ind];
   FOR_END
   rndm = randd();
   hh = 0;
   FOR p_ind FROM 0 TO nn - 1:
      hh += prob_arr_pc[p_ind] / sum;
      IF rndm < hh:
         FOR_EXIT;
      IF_END
   FOR_END
   RETURN p_ind;
FUNC_END

#TEST:normal_pdf(1)==0.2419707245191433497978;
#TEST:normal_cdf(0)==0.5;
#TEST:normal_cdf(1)==0.841344746068542948585232545632037922478;
#TEST:normal_cdf(2)==0.9772498680518207927997;
#TEST:normal_quantile(normal_cdf(1.34))==1.34;
#TEST:normal_quantile(0.5)-0.0;
#TEST:normal_quantile(0.8413447460685429485852)==1.0;
#TEST:normal_quantile(0.9772498680518207927997)==2.0;
#TEST:t_cdf(3,1)==0.8044988905221146790445;
#TEST:t_quantile(3,0.8044988905221146790445)==1;
#TEST:t_quantile__1(3,0.8044988905221146790445)==1;
#TEST:f_cdf(2,3,1.4)==0.6280026109165123031128;
#TEST:f_quantile(2,3,0.6280026109165123031128)==1.4;
#TEST:pareto_quantile(1.3,2.4,pareto_cdf(1.3,2.4,3.5))==3.5;
#TEST:geo_pdf(0.2,3)==0.1024;
#TEST:geo_cdf(0.2,7)==0.83222784;
#TEST:nbd_pdf(0.6,5,5)==0.1003290624;
#TEST:nbd_cdf(0.6,5,3)==0.5940864;
